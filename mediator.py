# -*- coding: utf-8 -*-
"""News api to knowledge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18H8YwlzMTK0r8EjcK2hQ0VnUMPEfLhNr

## Prerequisities
"""

!pip install newspaper3k lxml_html_clean newsapi-python chromadb langchain langchain-community tiktoken langchain-openai aiogram

#!pip install currentsapi

"""# Import"""

# OOPS
from abc import ABC, abstractmethod

# Telebot
from aiogram import Bot, Dispatcher, html
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.filters import CommandStart, Command
from aiogram.types import Message

# API
from newsapi import NewsApiClient
#from currentsapi import CurrentsAPI

# Newspaper3k
from newspaper import Article
from newspaper import ArticleException

# Vector database
import chromadb
from langchain_openai.embeddings import OpenAIEmbeddings
from langchain_openai import ChatOpenAI
from langchain.prompts import PromptTemplate

# Importing userdata (secrets)
from google.colab import userdata

# Turning off the warnings
import warnings
warnings.filterwarnings("ignore")

"""# News fetcher factory"""

# News fetcher factory design setup

class NewsFetcher(ABC):
  @abstractmethod
  def fetch(self, input:dict):
    pass

# Factory Newsapi-python


class NewsApiFetcher(NewsFetcher):
  """
  Fetching news using newsapi-python
  1. Headline
    Input:
          q - query
          category - general, sports, business, technology, ..
          language - 2 character language code "en"
          country - 2 character country code "us"

    Return:

  """

  def __init__(self):
    # Intialising the client
    self.client = NewsApiClient(api_key = userdata.get("newsapi-py"))

  def fetch(self, input):
    # Fetching headline
    if input["type"] =="headline":
      try:
        articles = self.client.get_top_headlines(q = input["query"], language = input["language"], country = input["country"])["articles"]
        return self.refactor(articles)
      except:
        return f"error"
    # Fetching related news
    elif input["type"]=="query":
      try:
        articles = self.client.get_everything(q = input["query"], language = input["language"], sort_by = input["sort"])["articles"]
        return self.refactor(articles)
      except:
        return f"error"

  # def fetch(self, input):
  #   # Fetching headline
  #   if input["type"] =="headline":
  #     articles = self.client.get_top_headlines(q = input["query"], language = input["language"], country = input["country"])["articles"]
  #     return self.refactor(articles)

  #   # Fetching related news
  #   elif input["type"]=="query":
  #     articles = self.client.get_everything(q = input["query"], language = input["language"], sort_by = input["sort"])["articles"]
  #     return self.refactor(articles)


  def refactor(self, articles):
    """Refactoring the api result"""

    # Handling empty result
    if len(articles) == 0:
      return f"No results found"

    # Refactoring all the news
    result = []
    for article in articles:
      result.append({"title":article["title"],"url":article["url"]})
    return result

"""### Debugging"""

#n = NewsApiFetcher()

#input = {"type":"query",
        #  "query":"ukraine russia war",
        #  "country":"us",
        #  "language":"en",
        #  "sort":"relevancy"}

#result = n.fetch(input)

#result

"""## Current affairs api"""

# Facotry Current affairs api


class CurrentAffairsFetcher(NewsFetcher):

  def __init__(self):
    self.client = CurrentsAPI(api_key = userdata.get("current_affairs_api"))


  def refactor(self, articles):
    """Refactoring the api result"""

    # Handling empty result
    if len(articles) == 0:
      return f"No results found"

      # Refactoring all the news
    result = []
    for article in articles:
      result.append({"title":article["title"],"url":article["url"],"desc":article["description"]})
    return result


  def fetch(self, input):

    # Fetching headline
    if input["type"] =="headline":
      try:
        articles = self.client.latest_news()["news"]
        return self.refactor(articles)
      except:
        return f"error"
    # Fetching related news
    elif input["type"]=="query":
      try:
        articles = self.client.search(keywords = input["query"], language = input["language"], sort_by = input["sort"])["news"]
        return self.refactor(articles)
      except:
        return f"error"


  # def fetch(self, input):   ## For deubgging
  #     # Fetching headline
  #   if input["type"] =="headline":
  #     articles = self.client.latest_news()["news"]
  #     return self.refactor(articles)


  #     # Fetching related news
  #   elif input["type"]=="query":

  #     articles = self.client.search(keywords = input["query"], language = input["language"])["news"]
  #     return self.refactor(articles)

"""## Retrieval Augmented generation"""

class RagNews:

  def __init__(self):
    # Vector database
    self.collection = chromadb.PersistentClient("./news_db").get_or_create_collection("query_news")

    # Intilising the Openai embeddings
    self.embedding_model = OpenAIEmbeddings(openai_api_key = userdata.get("openai"))
    self.llm = ChatOpenAI(model = "gpt-3.5-turbo", temperature =0.5, api_key=userdata.get("openai"))
    self.relevant_articles = None


  def extract_content(self,url):

     # News content extraction
    article = Article(url)
    article.download()
    try:
      article.parse()
      return article.title + "\n" + article.text
    except ArticleException:
      return False

  def vectorisation(self, articles):

    # Populating the vector database with news embeddings
    for index, article in enumerate(articles):
      content = self.extract_content(article["url"])
      if content != False:
        embedding = self.embedding_model.embed_query(content)
        self.collection.add(
          ids = [f"news_{index}"],
          embeddings = [embedding],
          documents = [content]
      )


  def retrieve_relevant_articles(self, articles, query):
    self.vectorisation(articles)
    query_embedding = self.embedding_model.embed_query(query)
    results = self.collection.query(
        query_embeddings = [query_embedding],
        n_results = 5)
    self.relevant_articles = results["documents"]


  def summariser(self,articles, query):
    self.retrieve_relevant_articles(articles, query)
    prompt = PromptTemplate(
      template = "Summarise the following news articles:\n{articles}",
      input_variables = ["articles"])
    summary = self.llm.invoke(prompt.format(articles ="\n\n".join(self.relevant_articles[0])))
    return summary

"""## Mediator"""

class NewsBotMediator():
  def __init__(self):
    self.newsapi = NewsApiFetcher()
    #self.cfapi = CurrentAffairsFetcher()
    self.rag = RagNews()


  def summarise(self, input):
    articles = self.newsapi.fetch(input)
    summary = self.rag.summariser(articles, input["query"])
    return summary

"""### Debugging"""

med = Mediator()

input = {"type":"query",
         "query":"ukraine russia war",
         "country":"us",
         "language":"en",
         "sort":"relevancy"}

summary = med.summarise(input)

summary.content



summary



"""# Aiogram side"""

# api_key for news_summary_agent
telebot_token = userdata.get("news_summary_agent_bot")

# Aiogram dispatcher connection
dp = Dispatcher()

# Mediator instance
mediator = NewsBotMediator()

# Handlers #

# /start handler
@dp.message(CommandStart())
async def command_start_handler(message:Message):
    """
    This handles the first message after the "/start"
    """

    await message.answer(f"Hello, {html.bold(message.from_user.full_name)}! This is news summariser powered by opeai. {mediator.newsapi}")

# /help handler
@dp.message(Command("help"))
async def help_handler(message:Message):
    """
    This handles the command /help
    """
    text = """
    Here is some usefull commands to get more out this bot:
    /start  - To getting started with news summariser
    /help   - To get help
    /option - To get list of all available options
    /info   - To get current options / Default options
    """
    await message.answer(text)


# /option handler
@dp.message(Command("option"))
async def info_handler(message:Message):
    """
    This handles the command "/info"
    """
    text = f"""{mediator.newsapi}.
    \nIf you want to change parameter:
    \nCountry--> set country {mediator.get_params('countries')}.
    \nCategory--> set category {mediator.get_params('categories')}.
    \nLanguage--> set language {mediator.get_params('languages')}"""
    await message.answer(text)


# /headline handler
@dp.message(Command("headline"))
async def headline_summary(message:Message):
  """
  This will return general healine
  """

  headline = mediator.headlines()
  await message.answer(headline)



# News Query Handler
@dp.message()
async def echo_handler(message:Message):
    """
    This handles any receiving message, except for the first message. This replies the same message back to the user
    """
    # try:
    #     result = mediator.query_router(str(message.text))
    #     await message.answer(str(result)[:4095])
    # except TypeError:
    #     await message.answer(f"UNSUPPORTED TYPE: {message}, please try again with supported type inputs")

    result = mediator.query_router(str(message.text))
    await message.answer(str(result)[:4095])


@dp.message()
async def main():
    """
    Initilisng bot
    """
    bot = Bot(token = telebot_token, default =DefaultBotProperties(parse_mode=ParseMode.HTML))
    await dp.start_polling(bot)
